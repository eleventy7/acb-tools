---
category: 'article'
cover: './top.jpg'
title: 'Low latency replication with replicated state machines'
description: 'Leveraging Aeron for low latency replication'
subtitle: 'An alternative approach to replicating byte buffers with low latency'
date: '2020-12-05'
tags: ['Distributed Systems']
published: false
state: work in progress
updated: '2020-12-06'
importance: low
series: 
seriesurl: 
review: continuous
---

<div class="bg-shaunnew-400 p-4 mb-4 rounded-md dark:text-black">
  <p class="font-bold">Summary</p>
  <p>If performance requirements demand it, computations can be shifted from clusters to cluster clients. Doing this typically requires some amount of shared state between the cluster and cluster clients, but there is no out of the box solution to replicate this data efficiently. If you have the need for replicating state with the lowest amount of latency then using a replicated state machine is the way to go. This approach is valid for both repositories (such as off heap DirectBuffer repositories) and other structures such as lists of POJOs.</p>
  <p class="italic">Scenarios where this approach should be avoided, and the state transfer supported by Merkle tree approach rather used:</p>
  <p><ul>
  <li>If the system can handle larger delays between updates, or it is optimal to batch updates to the cluster clients.</li>
  <li>If you need to reduce chattiness of the network. The replicated state machine approach means that every single operation performed needs to be replicated, while the Merkle tree approach computes the minimum set of pages to replicate to make the data sets identical</li>
  <li>If the gateway processes cannot apply the determinism demanded by the replicated state machine.</li>
  <li>If intraday gateway process restarts must be as quick as possible.</li>
    </ul>
  </p>
<div class="bg-shaunnew-800 flex flex-row p-2 rounded-md">
<div class="pr-2"><svg xmlns="http://www.w3.org/2000/svg" fill="none" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
</svg>
</div>
<div>See also: <a href="/article/efficient-state-transfer-with-merkle-trees/">State transfer with Merkle trees</a>
</div>
</div>
</div>


In order to improve a clustered system's throughput, we may wish to move some computation from the cluster to the edges. To do this, you typically need reference data available - data such as instruments, permissions etc. that are either not changing or are slowly changing. Replicating this data can be difficult to do efficiently - especially if you're working with off heap data structures.
Aeron Cluster is itself running a replicated state machine within the Raft protocol, however, the Raft protocol does not include a mechanism for the replication of datasets (or byte buffers) from cluster to cluster clients.


<div align="center">
<svg width="80%" height="auto" viewBox="0 0 810 149" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="591" width="219" height="149" rx="6" fill="#5AC8FA"/>
<text transform="translate(638 17)" fill="black" xml:space="preserve" font-family="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif" font-size="24" letter-spacing="0em"><tspan x="27.0938" y="23.14">Cluster</tspan></text>
<rect x="663" y="60" width="80" height="41" rx="6" fill="#FFCC02"/>
<text fill="black" xml:space="preserve" font-family="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif" font-size="24" letter-spacing="0em"><tspan x="673.719" y="87.14">State</tspan></text>
<rect x="296" width="167" height="149" rx="6" fill="#FF5544"/>
<rect width="167" height="149" rx="6" fill="#2ACC41"/>
<path d="M592.069 35.0198C592.65 34.4293 592.642 33.4796 592.052 32.8986L582.429 23.4299C581.839 22.8489 580.889 22.8565 580.308 23.447C579.727 24.0375 579.735 24.9872 580.325 25.5683L588.878 33.9849L580.462 42.5383C579.881 43.1288 579.889 44.0785 580.479 44.6595C581.07 45.2406 582.019 45.2329 582.6 44.6424L592.069 35.0198ZM463.012 36.5L591.012 35.4677L590.988 32.4678L462.988 33.5L463.012 36.5Z" fill="black"/>
<path d="M296.069 35.0198C296.65 34.4293 296.642 33.4796 296.052 32.8986L286.429 23.4299C285.839 22.8489 284.889 22.8565 284.308 23.447C283.727 24.0375 283.735 24.9872 284.325 25.5683L292.878 33.9849L284.462 42.5383C283.881 43.1288 283.889 44.0785 284.479 44.6595C285.07 45.2406 286.019 45.2329 286.6 44.6424L296.069 35.0198ZM167.012 36.5L295.012 35.4677L294.988 32.4678L166.988 33.5L167.012 36.5Z" fill="black"/>
<path d="M461.939 122.939C461.354 123.525 461.354 124.475 461.939 125.061L471.485 134.607C472.071 135.192 473.021 135.192 473.607 134.607C474.192 134.021 474.192 133.071 473.607 132.485L465.121 124L473.607 115.515C474.192 114.929 474.192 113.979 473.607 113.393C473.021 112.808 472.071 112.808 471.485 113.393L461.939 122.939ZM591 122.5L463 122.5V125.5L591 125.5V122.5Z" fill="black"/>
<path d="M166.939 122.939C166.354 123.525 166.354 124.475 166.939 125.061L176.485 134.607C177.071 135.192 178.021 135.192 178.607 134.607C179.192 134.021 179.192 133.071 178.607 132.485L170.121 124L178.607 115.515C179.192 114.929 179.192 113.979 178.607 113.393C178.021 112.808 177.071 112.808 176.485 113.393L166.939 122.939ZM296 122.5L168 122.5V125.5L296 125.5V122.5Z" fill="black"/>
<path d="M419.944 78.935C419.356 79.5183 419.352 80.4681 419.935 81.0563L429.441 90.6416C430.025 91.2298 430.974 91.2337 431.563 90.6503C432.151 90.067 432.155 89.1172 431.571 88.529L423.121 80.0088L431.642 71.5586C432.23 70.9753 432.234 70.0255 431.65 69.4373C431.067 68.8491 430.117 68.8452 429.529 69.4286L419.944 78.935ZM663.006 79.5L421.006 78.5L420.994 81.5L662.994 82.5L663.006 79.5Z" fill="black"/>
<text fill="black" xml:space="preserve" font-family="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif" font-size="18" letter-spacing="0em"><tspan x="473.048" y="26.48">Commands</tspan></text>
<text fill="black" xml:space="preserve" font-family="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif" font-size="18" letter-spacing="0em"><tspan x="501.382" y="118.48">Events</tspan></text>
<text transform="translate(317 17)" fill="black" xml:space="preserve" font-family="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif" font-size="24" letter-spacing="0em"><tspan x="18.9609" y="23.14">Gateway</tspan></text>
<text transform="translate(21 17)" fill="black" xml:space="preserve" font-family="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif" font-size="24" letter-spacing="0em"><tspan x="28.3594" y="23.14">Clients</tspan></text>
<rect x="341" y="60" width="80" height="41" rx="6" fill="#FFCC02"/>
<text fill="black" xml:space="preserve" font-family="-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif" font-size="24" letter-spacing="0em"><tspan x="352.719" y="87.14">State</tspan></text>
</svg>
</div>

There are two techniques available to replicate data across machines:
- *state transfer*: this can be a blunt tool, and is typically used for replicating memory across machines. With state transfer, the process simply transfers the current state of the world - without caring about how the data was created or modified. Raft uses this approach for snapshot transfer from cluster leader to new cluster followers on start up.
- *replicated state machines*: this is a finely grained approach, in which the exact set of operations performed are replicated across machines and replayed in the exact same order. The operations must be applied using deterministic logic. Raft uses this approach to apply changes to the cluster state once all snapshots are in place at follower nodes.

To replicate a DirectBuffer from the cluster to cluster client, we could use either state transfer or a replicated state machine. Each approach has its own pros and cons. 

- Replicated state machines are the better solution for transactional data or any other data which has a high sensitivity to being consistent across nodes within a short amount of time. The primary issue with replicating via replicated state machines to cluster clients is with late join scenarios. With this approach, all replicated state machine log entries would need to be replayed in order on top of a starting state and replayed through a deterministic process.  If you're running off of Aeron Archive for the transaction logs, you'd need to co-ordinate the replay and join onto an archive of operations performed. 
- State transfer is best focused on slowly changing data, such as reference data that can safely be updated within seconds of a batch update. State transfer approach allows a client to join at any time, and, by using Merkle Trees - as in the Viewstamped Replication paper - the most efficient data replication data set is always computed. No snapshot is required.

## Approaches for replicating via replicated state machines

In an Aeron cluster, we have at least two options to replicate data to the cluster clients:

- *using the cluster communication channel*: simply replicate every operation applied via the existing cluster client interface. On connect, cluster clients would request a new replication, and the current state would flow over normal channels. Then, once up-to-date, all further operations performed are sent in real-time to cluster clients.
- *using a dedicated replication channel*: add a dedicated replication Aeron Archive to the cluster and use multicast or MDC to deliver operations to cluster clients. This new Archive handles all replication tasks, and remains ordered. On reconnect, clients would need to replay all activity in the Archive to rebuild their state accordingly.

**WIP; still researching**