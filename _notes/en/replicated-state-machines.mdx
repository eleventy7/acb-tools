---
category: 'note'
cover: './top.jpg'
title: 'Replicated State Machines'
subtitle: 'Understand the heart of most fault tolerant distributed systems'
description: 'Understand the heart of most fault tolerant distributed systems'
date: '2020-12-12'
tags: ['Distributed Systems']
published: true
state: draft
updated: '2020-12-12'
importance: low
evergreen: üåø
series: 
seriesurl: 
review: continuous
---

Replicated state machines are a generalized approach for building fault-tolerant services with distributed systems. If you are familiar with the Gang of Four Design Patterns book, it is worth noting that the State Machine pattern described in the book has nothing to do with the way you would go about implementing a Replicated State Machine.

A Replicated State Machine is a software component that:

- Encodes its states internally
- Accepts commands that address a single method
- Deterministic methods process each command
- Internally, the commands mutate state and/or produce events.

If we have multiple Replicated State Machines that strictly follow the above rules, we can be certain that if they all start in the same initial state and they all process the commands in the same order, then they will have the same output events and the same internal state. The challenge then becomes how to get different machines to agree on the order of commands all while receiving concurrent client requests and in spite of failures.

Additional features that may be found with Replicated State Machines:

- Snapshots - this allows a state machine internal state to be captured at a moment in time
- Set - this allows the state machines internal state to be set to a given value.

These two additional features are important for the runtime operational aspects of a Replicated State Machine. If you wanted to capture the state of a state machine without needing to replay every command it had ever received since the initial state, you could take a snapshot of the internal state, save that to some place, and truncate every input command up-to-and-including the snapshot command. Then, when you want the state machine to recover it's internal state, you would set the internal state to the value produced by the snapshot.

## Sample State Machine

```java {numberLines}
public class ReplicatedStateMachine
{
    private int currentValue = 0;
    private List<EventListener> eventListeners = new ArrayList<>();

    public void addListener(EventListener eventListener)
    {
        eventListeners.add(eventListener);
    }

    public void add(AddCommand addCommand)
    {
        currentValue += addCommand.value;
        notifyListeners();
    }

    public void multiply(MultiplyCommand multiplyCommand)
    {
        currentValue *= multiplyCommand.value;
        notifyListeners();
    }

    public void set(SetCommand setCommand)
    {
        currentValue = setCommand.value;
        notifyListeners();
    }

    public void snapshot(SnapshotCommand snapshotCommand)
    {
        notifyListeners();
    }

    private void notifyListeners()
    {
        final NewValueEvent newValueEvent = new NewValueEvent();
        newValueEvent.currentValue = currentValue;
        for (final EventListener eventListener : eventListeners)
        {
            eventListener.newValue(newValueEvent);
        }
    }
}
```

For sake of simplicity, let's assume that the `EventListener` just logs the current state:

```java {numberLines}
public class EventListener
{
    private final Logger logger = LoggerFactory.getLogger(EventListener.class);

    public void newValue(NewValueEvent event)
    {
        logger.info("Current Value = {}", event.currentValue);
    }
}
```

If we then run following the commands:

```java {numberLines}
final EventListener eventListener = new EventListener();
final SimpleStateMachine bsm = new SimpleStateMachine();
bsm.addListener(eventListener);

final AddCommand add = new AddCommand();
add.value = 7;

final MultiplyCommand multiply = new MultiplyCommand();
multiply.value = 6;

final SetCommand set = new SetCommand();
set.value = 5;

bsm.set(set);
bsm.multiply(multiply);
bsm.add(add);
```

We can be certain for every scenario in which we run the set, followed by the multiply, followed by the add then the internal value will be 37. If we changed the order to set, then add, then multiply the internal value would be 72.

---

## Backlinks

<div class="flex flex-row p-2 rounded-md">
    <div class="pr-2">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" width="24" height="24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
</svg>
    </div>
    <div>
         <a href="../../article/primary-backup/">Primary-backup replication</a>
    </div>
</div>
<div class="flex flex-row p-2 rounded-md">
    <div class="pr-2">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" width="24" height="24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
</svg>
    </div>
    <div>
         <a href="../../note/split-brain">Split Brain</a>
    </div>
</div>
<div class="flex flex-row p-2 rounded-md">
    <div class="pr-2">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" width="24" height="24" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
</svg>
    </div>
    <div>
         <a href="../../article/chain-replication-craq#hermes">Chain replication, CRAQ and Hermes</a>
    </div>
</div>

---

## References

<div class="flex flex-row p-2 rounded-md">
    <div class="pr-2">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor">
          <path fill="#EFF7FE" d="M12 14l9-5-9-5-9 5 9 5z" />
          <path fill="#EFF7FE" d="M12 14l6.16-3.422a12.083 12.083 0 01.665 6.479A11.952 11.952 0 0012 20.055a11.952 11.952 0 00-6.824-2.998 12.078 12.078 0 01.665-6.479L12 14z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 14l9-5-9-5-9 5 9 5zm0 0l6.16-3.422a12.083 12.083 0 01.665 6.479A11.952 11.952 0 0012 20.055a11.952 11.952 0 00-6.824-2.998 12.078 12.078 0 01.665-6.479L12 14zm-4 6v-7.5l4-2.222" />
        </svg>
    </div>
    <div>
        F. B. Schneider, ‚ÄúImplementing fault-tolerant services using the state machine approach: a tutorial,‚Äù ACM Comput. Surv., vol. 22, no. 4, pp. 299‚Äì319, Dec. 1990, doi:  <a href="https://doi.org/10.1145/98163.98167" target="_blank">10.1145/98163.98167</a>
    </div>
</div>


---

## Change log

- Added 12 December 2020 
